# 基于生成器的协程
最开始是通过生成器实现协程的。

示例：
```python
def simple_coroutine():
    print('coroutine start')
    x = yield
    print('coroutine recv：', x)


if __name__ == "__main__":
    my_coroutine = simple_coroutine()
    print(my_coroutine)
    next(my_coroutine)
    print(my_coroutine.send(100))
"""
<generator object simple_coroutine at 0x0000022587502570>
coroutine start
coroutine recv： 100
Traceback (most recent call last):
  ...
StopIteration
"""
```
由于生成器并不是一次生成所有元素，而是一次一次的执行返回,需要使用next()激活生成器，send()方法
会像yield发送值，由yield表达式左边接收。

协程有四种状态
```python
GEN_CREATED # 等待开始执行
GEN_RUNNING # 解释器正在执行（只有在多线程应用中才能看到这个状态）
GEN_SUSPENDED # 在yield表达式处暂停
GEN_CLOSED # 执行结束
```

产生多个值示例：
```python
from inspect import getgeneratorstate


def simple_coroutine2(a):
    print('coroutine2 start: a=', a)
    b = yield a
    print('recv: b=', b)
    c = yield a + b
    print("recv: c=", c)


if __name__ == "__main__":
    my_coroutine = simple_coroutine2(14)
    # 此时的协程没有激活，处于GEN_CREATED状态
    print(getgeneratorstate(my_coroutine))

    # 激活协程，next返回值为yield右边表达式返回值
    print(next(my_coroutine))

    # yield产出a的值之后，暂停，等待为b赋值，所以状态是GEN_SUSPENDED
    print(getgeneratorstate(my_coroutine))

    # 把数字28发送给暂停的协程，计算出 a+b的值，协程暂停，等待为b赋值
    print(my_coroutine.send(28))
    
    # 把 数字99发送给暂停的协程，产出c的值，协程终止，抛出StopIteration异常
    print(my_coroutine.send(99))
    
    # 此时协程已经结束，状态应该是GEN_CLOSED状态
    print(getgeneratorstate(my_coroutine))
"""
GEN_CREATED
coroutine2 start: a= 14
14
GEN_SUSPENDED
recv: b= 28
42 
recv: c= 99
Traceback (most recent call last):
  ...
StopIteration
"""
```
在赋值语句中，=右面的代码在赋值之间执行，对于 `b=yield a`这行代码来说，等到客户端
激活协程时才会设定b的值。
## 使用协程计算移动平均值
示例：
```python
def averager():
    total = 0.0
    count = 0
    average = None
    while True:
        term = yield average
        total += term
        count += 1
        average = total / count


if __name__ == "__main__":
    coro_avg = averager()
    
    print(next(coro_avg))
    print(coro_avg.send(10))
    print(coro_avg.send(30))
    print(coro_avg.send(5))
"""
None
10.0
20.0
15.0
"""
```
## 预激协程装饰器
协程在启动之前，需要预激，除了使用next方法，可以使用装饰器，简化激活协程的过程

示例:
```python
from functools import wraps


def coroutine(func):
    @wraps(func)
    def primer(*args, **kwargs):
        gen = func(*args, **kwargs)
        next(gen)
        return gen
    return primer


@coroutine
def averager():
    total = 0.0
    count = 0
    average = None
    while True:
        term = yield average
        total += term
        count += 1
        average = total / count


if __name__ == "__main__":
    coro_avg = averager()
    print(coro_avg.send(10))
    print(coro_avg.send(30))
    print(coro_avg.send(5))
"""
10.0
20.0
15.0
"""
```


# 事件循环
在Asyncio模块中，每一个进程都有一个事件循环。

在计算系统中，可以产生事件的实体叫做事件源，能处理事件的实体叫做事件处理者。此外，还有一些第三方实体叫做事件循环。它的作用是管理所有的事件，在整个程序运行过程中不断循环执行，追踪事件发生的顺序将它们放到队列中，当主线程空闲的时候，调用相应的事件处理者处理事件。

事件循环主要方法:
- loop = get_event_loop(): 得到当前上下文的事件循环。
- loop.call_later(time_delay, callback, argument): 延后 time_delay 秒再执行 callback 方法。
- loop.call_soon(callback, argument): 尽可能快调用 callback, call_soon() 函数结束，主线程回到事件循环之后就会马上调用 callback 。
- loop.time(): 以float类型返回当前时间循环的内部时间。
- asyncio.set_event_loop(): 为当前上下文设置事件循环。
- asyncio.new_event_loop(): 根据此策略创建一个新的时间循环并返回。
- loop.run_forever(): 在调用 stop() 之前将一直运行。

示例：
```python
import asyncio


def function1(end_time, loop):
    print('function1 called')
    if (loop.time() + 1.0) < end_time:
        loop.call_later(1, function2, end_time, loop)
    else:
        loop.stop()


def function2(end_time, loop):
    print('function2 called')
    if (loop.time() + 1.0) < end_time:
        loop.call_later(1, function3, end_time, loop)
    else:
        loop.stop()


def function3(end_time, loop):
    print('function3 called')
    if (loop.time() + 1.0) < end_time:
        loop.call_later(1, function1, end_time, loop)
    else:
        loop.stop()


def function4(end_time, loop):
    print('function4 called')
    if (loop.time() + 1.0) < end_time:
        loop.call_later(1, function4, end_time, loop)
    else:
        loop.stop()


# 定义事件循环对象
loop = asyncio.get_event_loop()
end_loop = loop.time() + 9.0

loop.call_soon(function1, end_loop, loop)

loop.run_forever()
loop.close()

"""
function1 called
function2 called
function3 called
function1 called
function2 called
function3 called
function1 called
function2 called
function3 called
"""
```
