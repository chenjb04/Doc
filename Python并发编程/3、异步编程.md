# 基于生成器的协程
最开始是通过生成器实现协程的。

示例：
```python
def simple_coroutine():
    print('coroutine start')
    x = yield
    print('coroutine recv：', x)


if __name__ == "__main__":
    my_coroutine = simple_coroutine()
    print(my_coroutine)
    next(my_coroutine)
    print(my_coroutine.send(100))
"""
<generator object simple_coroutine at 0x0000022587502570>
coroutine start
coroutine recv： 100
Traceback (most recent call last):
  ...
StopIteration
"""
```
由于生成器并不是一次生成所有元素，而是一次一次的执行返回,需要使用next()激活生成器，send()方法
会像yield发送值，由yield表达式左边接收。

协程有四种状态
```python
GEN_CREATED # 等待开始执行
GEN_RUNNING # 解释器正在执行（只有在多线程应用中才能看到这个状态）
GEN_SUSPENDED # 在yield表达式处暂停
GEN_CLOSED # 执行结束
```

产生多个值示例：
```python
from inspect import getgeneratorstate


def simple_coroutine2(a):
    print('coroutine2 start: a=', a)
    b = yield a
    print('recv: b=', b)
    c = yield a + b
    print("recv: c=", c)


if __name__ == "__main__":
    my_coroutine = simple_coroutine2(14)
    # 此时的协程没有激活，处于GEN_CREATED状态
    print(getgeneratorstate(my_coroutine))

    # 激活协程，next返回值为yield右边表达式返回值
    print(next(my_coroutine))

    # yield产出a的值之后，暂停，等待为b赋值，所以状态是GEN_SUSPENDED
    print(getgeneratorstate(my_coroutine))

    # 把数字28发送给暂停的协程，计算出 a+b的值，协程暂停，等待为b赋值
    print(my_coroutine.send(28))
    
    # 把 数字99发送给暂停的协程，产出c的值，协程终止，抛出StopIteration异常
    print(my_coroutine.send(99))
    
    # 此时协程已经结束，状态应该是GEN_CLOSED状态
    print(getgeneratorstate(my_coroutine))
"""
GEN_CREATED
coroutine2 start: a= 14
14
GEN_SUSPENDED
recv: b= 28
42 
recv: c= 99
Traceback (most recent call last):
  ...
StopIteration
"""
```
在赋值语句中，=右面的代码在赋值之间执行，对于 `b=yield a`这行代码来说，等到客户端
激活协程时才会设定b的值。
## 使用协程计算移动平均值
示例：
```python
def averager():
    total = 0.0
    count = 0
    average = None
    while True:
        term = yield average
        total += term
        count += 1
        average = total / count


if __name__ == "__main__":
    coro_avg = averager()
    
    print(next(coro_avg))
    print(coro_avg.send(10))
    print(coro_avg.send(30))
    print(coro_avg.send(5))
"""
None
10.0
20.0
15.0
"""
```
## 预激协程装饰器
协程在启动之前，需要预激，除了使用next方法，可以使用装饰器，简化激活协程的过程

示例:
```python
from functools import wraps


def coroutine(func):
    @wraps(func)
    def primer(*args, **kwargs):
        gen = func(*args, **kwargs)
        next(gen)
        return gen
    return primer


@coroutine
def averager():
    total = 0.0
    count = 0
    average = None
    while True:
        term = yield average
        total += term
        count += 1
        average = total / count


if __name__ == "__main__":
    coro_avg = averager()
    print(coro_avg.send(10))
    print(coro_avg.send(30))
    print(coro_avg.send(5))
"""
10.0
20.0
15.0
"""
```
## 终止协程和异常处理
有两个方法，可以显示的把异常发送给协程。
- generator.throw()
    
    使生成器在暂停的yield表达式出抛出指定的异常，如果生成器处理了抛出的异常，代码会向前执行到下一个yield表达式，
    而产出的值会成为调用generator.throw方法得到的返回值，如果生成器没有处理异常
    ，异常会向上冒泡，传递到调用方的上下文中。
    
- generator.close()
        
     使生成器在暂停的yield表达式出抛出GeneratorExit的异常。如果生成器没有处理这个异常，或者抛出stopIteration，调用方不会报错。
     如果收到GeneratorExit的异常，生成器一定不能产出值，否则会抛出RuntimeError。生成器抛出的其他异常会向上冒泡，传递给调用方。

示例：
```python
from inspect import getgeneratorstate


class DemoException(Exception):
    pass


def demo_exc_handing():
    print('coroutine start')
    while True:
        try:
            x = yield
        except DemoException:
            print('DemoException handled')
        else:
            print("coroutine recv: {!r}".format(x))

    # 这一行代码永远不会执行，因为只有未处理的异常才会终止无限循环，而出现未处理的异常，协程会立马终止
    raise RuntimeError('this line should never run')


if __name__ == "__main__":
    exc_coro = demo_exc_handing()
    next(exc_coro)
    exc_coro.send(11)
    exc_coro.send(22)
    # exc_coro.close()
    # print(getgeneratorstate(exc_coro))

    # 把DemoException异常传入demo_exc_handing协程，他会处理，然后继续执行
    exc_coro.throw(DemoException)
    print(getgeneratorstate(exc_coro))

    # 如果传入未处理的异常，协程会停止
    exc_coro.throw(ZeroDivisionError)
"""
coroutine start
coroutine recv: 11
coroutine recv: 22
DemoException handled
GEN_SUSPENDED
"""
```
## 让协程返回值
示例：
```python
from collections import namedtuple


Result = namedtuple('Result', 'count average')


def averager():
    total = 0.0
    count = 0
    average = None
    while True:
        term = yield
        if term is None:
            break
        total += term
        count += 1
        average = total / count
    return Result(count, average)


if __name__ == "__main__":
    coro_avg = averager()
    next(coro_avg)
    coro_avg.send(10)
    coro_avg.send(30)
    coro_avg.send(6.5)
    # 发送None终止循环，导致协程结束，生成器抛出StopIteration异常，返回结果保存在异常对象value属性中。
    # coro_avg.send(None)
    result = None
    try:
        coro_avg.send(None)
    except StopIteration as e:
        result = e.value
    print(result)
"""
Result(count=3, average=15.5)
"""
```
## yield from
yield form是全新的语言结构，作用比yield作用大很多

yield from 可以简化for循环中的yield表达式

示例：
```python
def gen():
    for c in 'AB':
        yield c
    for i in range(1, 3):
        yield i


def gen1():
    yield from 'AB'
    yield from range(1, 3)


if __name__ == '__main__':
    print(list(gen()))
    print(list(gen1()))
"""
['A', 'B', 1, 2]
['A', 'B', 1, 2]
"""
```
yield from 不止可以代替for循环，主要功能是打开双向通道，把最外层的调用方和最内层
的子生成器连接起来，这样二者可以直接发送和产出值，还可以直接传入异常，这样不用再协程中有大量处理异常的代码。

- 委派生成器：包含yield from <iterable> 表达式生成器函数。
- 子生成器：从yield from 表达式中 <iterable>部分获取的生成器。
- 调用方：调用委派生成器的客户端代码。

示例：
```python

from collections import namedtuple


Result = namedtuple('Result', 'count average')


# 子生成器
def averager():
    total = 0.0
    count = 0
    average = None
    while True:
        term = yield
        if term is None:
            break
        total += term
        count += 1
        average = total / count
    return Result(count, average)


# 委派生成器
def grouper(results, key):
    while True:
        results[key] = yield from averager()


# 调用方
def main(data):
    results = {}
    for key, values in data.items():
        # group发送的每个值都会由yield from处理，通过管道传给averager实例。
        group = grouper(results, key)
        next(group)
        for value in values:
            group.send(value)
        # 如果子生成器不终止，委派生成器会在yield from表达式处永远暂停
        group.send(None)
    report(results)


def report(results):
    for key, result in sorted(results.items()):
        group, unit = key.split(';')
        print('{:2} {:5} average {:.2f}{}'.format(result.count, group, result.average, unit))


data = {
    'girls;kg':
        [40.9, 38.5, 44.3, 42.2, 45.2, 41.7, 44.5, 38.0, 40.6, 44.5],
    'girls;m':
        [1.6, 1.51, 1.4, 1.3, 1.41, 1.39, 1.33, 1.46, 1.45, 1.43],
    'boys;kg':
        [39.0, 40.8, 43.2, 40.8, 43.1, 38.6, 41.4, 40.6, 36.3],
    'boys;m':
        [1.38, 1.5, 1.32, 1.25, 1.37, 1.48, 1.25, 1.49, 1.46],
}


if __name__ == '__main__':
    main(data)

"""
 9 boys  average 40.42kg
 9 boys  average 1.39m
10 girls average 42.04kg
10 girls average 1.43m
"""
```
pep380中阐述了yield from的行为

- 子生成器产生的值直接传给委派生成器的调用方
- 使用send方法发给委派生成器的值都会直接传给子生成器。如果发送的是None值，那么会
调用子生成器的__next__方法。如果发送的值不是None，那么会调用子生成器的send方法。
如果调用的方法抛出stopIteration异常，那么委派生成器恢复运行，任何其他异常都会向上冒泡，传给委派生成器。
- 生成器退出时，生成器中的return expr表达式会触发stopIteration异常抛出
- yield from表达式的值是子生成器终止时传给stopIteration异常的第一个参数。
- 除了GeneratorExit 异常外的其他抛给委派生产器的异常，将会被传递到迭代器的throw()方法。如果迭代器throw()调用产生了StopIteration异常，委派生产器恢复并继续执行，其他异常则传递给委派生产器。
- 如果GeneratorExit异常被抛给委派生产器，或者委派生产器的close()方法被调用，如果迭代器有close()的话也将被调用。如果close()调用产生异常，异常将传递给委派生产器。否则，委派生产器将抛出GeneratorExit 异常。




# 事件循环
在Asyncio模块中，每一个进程都有一个事件循环。

在计算系统中，可以产生事件的实体叫做事件源，能处理事件的实体叫做事件处理者。此外，还有一些第三方实体叫做事件循环。它的作用是管理所有的事件，在整个程序运行过程中不断循环执行，追踪事件发生的顺序将它们放到队列中，当主线程空闲的时候，调用相应的事件处理者处理事件。

事件循环主要方法:
- loop = get_event_loop(): 得到当前上下文的事件循环。
- loop.call_later(time_delay, callback, argument): 延后 time_delay 秒再执行 callback 方法。
- loop.call_soon(callback, argument): 尽可能快调用 callback, call_soon() 函数结束，主线程回到事件循环之后就会马上调用 callback 。
- loop.time(): 以float类型返回当前时间循环的内部时间。
- asyncio.set_event_loop(): 为当前上下文设置事件循环。
- asyncio.new_event_loop(): 根据此策略创建一个新的时间循环并返回。
- loop.run_forever(): 在调用 stop() 之前将一直运行。

示例：
```python
import asyncio


def function1(end_time, loop):
    print('function1 called')
    if (loop.time() + 1.0) < end_time:
        loop.call_later(1, function2, end_time, loop)
    else:
        loop.stop()


def function2(end_time, loop):
    print('function2 called')
    if (loop.time() + 1.0) < end_time:
        loop.call_later(1, function3, end_time, loop)
    else:
        loop.stop()


def function3(end_time, loop):
    print('function3 called')
    if (loop.time() + 1.0) < end_time:
        loop.call_later(1, function1, end_time, loop)
    else:
        loop.stop()


def function4(end_time, loop):
    print('function4 called')
    if (loop.time() + 1.0) < end_time:
        loop.call_later(1, function4, end_time, loop)
    else:
        loop.stop()


# 定义事件循环对象
loop = asyncio.get_event_loop()
end_loop = loop.time() + 9.0

loop.call_soon(function1, end_loop, loop)

loop.run_forever()
loop.close()

"""
function1 called
function2 called
function3 called
function1 called
function2 called
function3 called
function1 called
function2 called
function3 called
"""
```
