# 创建线程

`threading`库可以在单独的线程中执行任何的在 Python 中可以调用的对象。你可以创建一个 `Thread` 对象并将你要执行的对象以 target 参数的形式提供给该对象。

示例

```python
import threading
import time


def countdown(n):
    while n > 0:
        print("t", n)
        n -= 1
        time.sleep(2)


# 创建线程
t = threading.Thread(target=countdown, args=(10, ))
# 启动线程
t.start()
```
创建好线程之后，需要使用``start()``方法来启动。Python中的线程会在一个单独的系统级线程中执行（比如说一个 POSIX 线程或者一个 Windows 线程），这些线程将由操作系统来全权管理。线程一旦启动，将独立执行直到目标函数返回。
可以查看一个线程的执行状态。
```python
# 查看线程对象状态
if t.is_alive():
    print('running')
else:
    print('done')
```
## join()方法
一：一个进程启动后，会默认产生一个主线程，因为线程是程序执行的最小单位，设置多线程时，主线程会创建多个子线程，在默认情况下，主线程执行完自己的任务就会退出，此时子线程还在继续执行自己的任务，直到自己的任务结束。
示例：
```python
import time
import threading


def run():
    time.sleep(2)
    print('current threading is ', threading.current_thread().name)
    time.sleep(2)


if __name__ == '__main__':
    start_time = time.time()
    print("main threading is ", threading.current_thread().name)
    thread_list = []
    for i in range(5):
        t = threading.Thread(target=run)
        thread_list.append(t)
    for t in thread_list:
        t.start()
    print('main threading {} done use time {}'.format(threading.current_thread().name, time.time() - start_time))

"""
main threading is  MainThread
main threading MainThread done use time 0.0008857250213623047
current threading is:  Thread-2
current threading is:  Thread-1
current threading is:  Thread-3
current threading is:  Thread-5
current threading is:  Thread-4
"""
```
对主线程计时，主线程结束，计时也随之结束。可以看出主线程中的子线程还没有完成，主线程就退出了。

二：设置子线程为守护线程时，主线程一旦结束，子线程全部终止，出现的问题就是子线程任务还没有完成，就被迫结束了。

示例：
```python
import threading
import time


def run():
    time.sleep(2)
    print("current threading is: ", threading.current_thread().name)
    time.sleep(2)


if __name__ == '__main__':
    start_time = time.time()
    print("main threading is ", threading.current_thread().name)
    thread_list = []
    for _ in range(5):
        t = threading.Thread(target=run)
        thread_list.append(t)
    for t in thread_list:
        # 设置守护进程
        t.setDaemon(True)
        t.start()
    print('main threading {} done use time {}'.format(threading.current_thread().name, time.time() - start_time))

"""
main threading is  MainThread
main threading MainThread done use time 0.0009968280792236328
"""
```
可以看出，子线程还没有执行，就已经结束了。

`join()`的作用就是线程同步，即主线程任务结束后，进入阻塞状态，直到子线程任务完成，主线程再终止。

示例：
```python
import time
import threading


def run():
    time.sleep(2)
    print('current threading is: ', threading.current_thread().name)
    time.sleep(2)


if __name__ == '__main__':
    start_time = time.time()
    print("main threading is ", threading.current_thread().name)
    thread_list = []
    for i in range(5):
        t = threading.Thread(target=run)
        thread_list.append(t)
    for t in thread_list:
        t.start()
    for t in thread_list:
        t.join()
    print('main threading {} done use time {}'.format(threading.current_thread().name, time.time() - start_time))

"""
main threading is  MainThread
current threading is:  Thread-1
current threading is:  Thread-5
current threading is:  Thread-4
current threading is:  Thread-3
current threading is:  Thread-2
main threading MainThread done use time 4.0057477951049805
"""
```
可以看到，子线程都执行完，主线程才退出。

`join()`有个**timeout**参数。

- 设置线程为守护线程时，含义是主线程对于子线程等待timeout的时间将会杀死该子线程，最后退出程序。如果同时有N个子线程join(timeout），那么实际上主线程会等待的超时时间最长为 N * timeout， 因为每个子线程的超时开始时刻是上一个子线程超时结束的时刻。就是给每个子线程一个timeout的时间，让他去执行，时间一到，不管任务有没有完成，直接杀死。
- 非守护线程时，timeout无效，主线程会一直等待子线程结束

示例:
```python
import time
import threading


def run():
    time.sleep(2)
    print('current threading is: ', threading.current_thread().name)
    time.sleep(2)


if __name__ == '__main__':
    start_time = time.time()
    print("main threading is ", threading.current_thread().name)
    thread_list = []
    for i in range(5):
        t = threading.Thread(target=run)
        thread_list.append(t)
    for t in thread_list:
        t.setDaemon(True)
        t.start()
    for t in thread_list:
        t.join(timeout=1)
    print('main threading {} done use time {}'.
```
## 继承线程
可以通过继承Thread类来实现线程类

示例：
```python
import threading
import time


class Mythread(threading.Thread):
    def __init__(self, n):
        super().__init__()
        self.n = n

    def run(self):
        while self.n > 0:
            print('t', self.n)
            self.n -= 1
            time.sleep(2)


if __name__ == '__main__':
    t = Mythread(5)
    t.start()
```
# 线程同步方式
当两个或以上对共享内存的操作发生在并发线程中，并且至少有一个可以改变数据，又没有同步机制的条件下，就会产生竞争条件，可能会导致执行无效代码、bug、或异常行为。
## 使用lock进行线程同步
竞争条件最简单的解决方法是使用锁。锁的操作非常简单，当一个线程需要访问部分共享内存时，它必须先获得锁才能访问。此线程对这部分共享资源使用完成之后，该线程必须释放锁，然后其他线程就可以拿到这个锁并访问这部分资源了。

但是这种情况会造成死锁的现象。

示例：
```python
import threading

shard_recorce_with_lock = 0
shard_recorce_no_lock = 0

# 定义锁
shard_recorce_lock = threading.Lock()


def increment_with_lock():
    """
    加1操作
    :return:
    """
    global shard_recorce_with_lock
    for _ in range(1000000):
        # 获取锁
        shard_recorce_lock.acquire()
        # 加1操作
        shard_recorce_with_lock += 1
        # 释放锁
        shard_recorce_lock.release()


def decrement_with_lock():
    """
    减一操作
    :return:
    """
    global shard_recorce_with_lock
    for _ in range(1000000):
        # 获取锁
        shard_recorce_lock.acquire()
        # 加1操作
        shard_recorce_with_lock -= 1
        # 释放锁
        shard_recorce_lock.release()


def increment_no_lock():
    """
    加1操作
    :return:
    """
    global shard_recorce_no_lock
    for _ in range(1000000):
        # 加1操作
        shard_recorce_no_lock += 1


def decrement_no_lock():
    """
    减一操作
    :return:
    """
    global shard_recorce_no_lock
    for _ in range(1000000):
        # 加1操作
        shard_recorce_no_lock -= 1


if __name__ == '__main__':
    t1 = threading.Thread(target=increment_with_lock)
    t2 = threading.Thread(target=decrement_with_lock)
    t3 = threading.Thread(target=increment_no_lock)
    t4 = threading.Thread(target=decrement_no_lock)
    t1.start()
    t2.start()
    t3.start()
    t4.start()
    t1.join()
    t2.join()
    t3.join()
    t4.join()
    print('with lock result: ', shard_recorce_with_lock)
    print('no lock result: ', shard_recorce_no_lock)

"""
with lock result:  0
no lock result:  146758
"""
```
加锁 不加锁的现象很明显。

使用lock的缺点是可能会造成死锁的结果，也会引起不必要的开销，慎用。
## 使用Rlock进行线程同步
 多重锁，在同一线程中可用被多次acquire。如果使用RLock，那么acquire和release必须成对出现，
调用了n次acquire锁请求，则必须调用n次的release才能在线程中释放锁对象

示例：
```python

```
## Event对象
线程的一个关键特性就是独立运行且状态不可预测。程序中的其他线程需要通过判断某个线程的状态来确定自己下一步的操作，这时线程同步问题就会变得非常棘手。为了解决这些问题，我们需要使用 threading 库中的 Event 对象。Event 对象包含一个可由线程设置的信号标志，它允许线程等待某些事件的发生。在初始情况下，event 对象中的信号标志被设置为假。如果有线程等待一个 event 对象，而这个 event 对象的标志为假，那么这个线程将会被一直阻塞直至该标志为真。一个线程如果将一个 event 对象的信号标志设置为真，它将唤醒所有等待这个 event 对象的线程。如果一个线程等待一个已经被设置为真的 event 对象，那么它将忽略这个事件，继续执行。
直白一点就是等待事件触发。
- 创建event 对象

    event = threading.Event()
- 设置信号
    event.set()
    
    可以设置event对象内部信号量为True，is_set()可以判断内部信号量的状态
   
- 清除信号 event.clear()

    可以设置event对象内部信号为False

- 等待 event.wait()
    
    必须为True时，wait才会很快执行返回，为假时，会一直等待为真才会返回
   
    
示例：
```python
import threading
import time

# 创建event对象
event = threading.Event()


def cal(name: str):
    print("{} start".format(threading.current_thread().name))
    print('{} ready cal'.format(name))
    # 阻塞状态
    event.wait()
    print('{} recv'.format(threading.current_thread().name))
    print('{} runing cal'.format(name))


for i in range(2):
    t = threading.Thread(target=cal, args=('num' + str(i), ))
    t.start()
time.sleep(2)
print('main threading send event')
event.set()

"""
Thread-1 start
num0 ready cal
Thread-2 start
num1 ready cal
main threading send event
Thread-1 recv
num0 runing cal
Thread-2 recv
num1 runing cal
"""
```

## 线程间通信
从一个线程向另一个线程发送数据最安全的方式可能就是使用 queue 库中的队列了。创建一个被多个线程共享的 Queue 对象，这些线程通过使用 put() 和 get() 操作来向队列中添加或者删除元素。

示例：
```python

```