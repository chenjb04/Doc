# 创建进程
multiprocessing库可以创建进程。

示例：
```python
import multiprocessing


def foo(i):
    print('called function in process: ', i)


if __name__ == '__main__':
    for i in range(5):
        p = multiprocessing.Process(target=foo, args=(i, ))
        p.start()
        p.join()
"""
called function in process:  0
called function in process:  1
called function in process:  2
called function in process:  3
called function in process:  4
"""
```
注意：如果没有 join() ，主进程退出之后子进程会留在idle中，你必须手动杀死它们。
## 进程命名
命名进程的方法和线程差不多

示例：
```python
import multiprocessing
import time


def foo():
    name = multiprocessing.current_process().name
    print('staring: ', name)
    time.sleep(3)
    print('exiting: ', name)


if __name__ == '__main__':
    process_with_name = multiprocessing.Process(target=foo, name='foo_process')
    process_with_default_name = multiprocessing.Process(target=foo)
    process_with_name.start()
    process_with_default_name.start()
    process_with_name.join()
    process_with_default_name.join()

"""
Starting foo_process
Starting Process-2
Exiting foo_process
Exiting Process-2
"""
```
## 守护进程
如果需要处理比较巨大的任务，又不需要人为干预，将其作为后台进程执行是个非常常用的编程模型。此进程又可以和其他进程并发执行。

示例：
```python

import multiprocessing
import time


def foo():
    name = multiprocessing.current_process().name
    print('starting: ', name)
    time.sleep(3)
    print('exiting: ', name)


if __name__ == '__main__':
    daemon_process = multiprocessing.Process(target=foo, name='daemon_process')
    daemon_process.daemon = True
    no_daemon = multiprocessing.Process(target=foo, name='no_daemon')
    no_daemon.daemon = False
    daemon_process.start()
    no_daemon.start()
    daemon_process.join()
    no_daemon.join()

"""
starting:  daemon_process
starting:  no_daemon
exiting:  daemon_process
exiting:  no_daemon
"""
```
## 杀死进程
