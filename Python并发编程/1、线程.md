# 创建线程

`threading`库可以在单独的线程中执行任何的在 Python 中可以调用的对象。你可以创建一个 `Thread` 对象并将你要执行的对象以 target 参数的形式提供给该对象。

示例

```python
import threading
import time


def countdown(n):
    while n > 0:
        print("t", n)
        n -= 1
        time.sleep(2)


# 创建线程
t = threading.Thread(target=countdown, args=(10, ))
# 启动线程
t.start()
```
创建好线程之后，需要使用``start()``方法来启动。Python中的线程会在一个单独的系统级线程中执行（比如说一个 POSIX 线程或者一个 Windows 线程），这些线程将由操作系统来全权管理。线程一旦启动，将独立执行直到目标函数返回。
可以查看一个线程的执行状态。
```python
# 查看线程对象状态
if t.is_alive():
    print('running')
else:
    print('done')
```
## join()方法
一：一个进程启动后，会默认产生一个主线程，因为线程是程序执行的最小单位，设置多线程时，主线程会创建多个子线程，在默认情况下，主线程执行完自己的任务就会退出，此时子线程还在继续执行自己的任务，直到自己的任务结束。
示例：
```python
import time
import threading


def run():
    time.sleep(2)
    print('current threading is ', threading.current_thread().name)
    time.sleep(2)


if __name__ == '__main__':
    start_time = time.time()
    print("main threading is ", threading.current_thread().name)
    thread_list = []
    for i in range(5):
        t = threading.Thread(target=run)
        thread_list.append(t)
    for t in thread_list:
        t.start()
    print('main threading {} done use time {}'.format(threading.current_thread().name, time.time() - start_time))

"""
main threading is  MainThread
main threading MainThread done use time 0.0008857250213623047
current threading is:  Thread-2
current threading is:  Thread-1
current threading is:  Thread-3
current threading is:  Thread-5
current threading is:  Thread-4
"""
```
对主线程计时，主线程结束，计时也随之结束。可以看出主线程中的子线程还没有完成，主线程就退出了。

二：设置子线程为守护线程时，主线程一旦结束，子线程全部终止，出现的问题就是子线程任务还没有完成，就被迫结束了。

示例：
```python
import threading
import time


def run():
    time.sleep(2)
    print("current threading is: ", threading.current_thread().name)
    time.sleep(2)


if __name__ == '__main__':
    start_time = time.time()
    print("main threading is ", threading.current_thread().name)
    thread_list = []
    for _ in range(5):
        t = threading.Thread(target=run)
        thread_list.append(t)
    for t in thread_list:
        # 设置守护进程
        t.setDaemon(True)
        t.start()
    print('main threading {} done use time {}'.format(threading.current_thread().name, time.time() - start_time))

"""
main threading is  MainThread
main threading MainThread done use time 0.0009968280792236328
"""
```
可以看出，子线程还没有执行，就已经结束了。

`join()`的作用就是线程同步，即主线程任务结束后，进入阻塞状态，直到子线程任务完成，主线程再终止。

示例：
```python
import time
import threading


def run():
    time.sleep(2)
    print('current threading is: ', threading.current_thread().name)
    time.sleep(2)


if __name__ == '__main__':
    start_time = time.time()
    print("main threading is ", threading.current_thread().name)
    thread_list = []
    for i in range(5):
        t = threading.Thread(target=run)
        thread_list.append(t)
    for t in thread_list:
        t.start()
    for t in thread_list:
        t.join()
    print('main threading {} done use time {}'.format(threading.current_thread().name, time.time() - start_time))

"""
main threading is  MainThread
current threading is:  Thread-1
current threading is:  Thread-5
current threading is:  Thread-4
current threading is:  Thread-3
current threading is:  Thread-2
main threading MainThread done use time 4.0057477951049805
"""
```
可以看到，子线程都执行完，主线程才退出。

`join()`有个**timeout**参数。

- 设置线程为守护线程时，含义是主线程对于子线程等待timeout的时间将会杀死该子线程，最后退出程序。如果同时有N个子线程join(timeout），那么实际上主线程会等待的超时时间最长为 N * timeout， 因为每个子线程的超时开始时刻是上一个子线程超时结束的时刻。就是给每个子线程一个timeout的时间，让他去执行，时间一到，不管任务有没有完成，直接杀死。
- 非守护线程时，timeout无效，主线程会一直等待子线程结束

示例:
```python
import time
import threading


def run():
    time.sleep(2)
    print('current threading is: ', threading.current_thread().name)
    time.sleep(2)


if __name__ == '__main__':
    start_time = time.time()
    print("main threading is ", threading.current_thread().name)
    thread_list = []
    for i in range(5):
        t = threading.Thread(target=run)
        thread_list.append(t)
    for t in thread_list:
        t.setDaemon(True)
        t.start()
    for t in thread_list:
        t.join(timeout=1)
    print('main threading {} done use time {}'.
```
## 继承线程
可以通过继承Thread类来实现线程类

示例：
```python
import threading
import time


class Mythread(threading.Thread):
    def __init__(self, n):
        super().__init__()
        self.n = n

    def run(self):
        while self.n > 0:
            print('t', self.n)
            self.n -= 1
            time.sleep(2)


if __name__ == '__main__':
    t = Mythread(5)
    t.start()
```
